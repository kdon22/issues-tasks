"use client";

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useCurrentWorkspace } from './use-current-workspace';
import { createActionClient, ActionClient, ActionRequest, ActionResponse } from '@/lib/api/action-client';
import { useState as useReactState, useEffect, useMemo } from 'react';
import { 
  Team, 
  Project, 
  Label, 
  Member, 
  IssueType, 
  State, 
  StatusFlow,
  FieldSet,
  Issue, 
  Comment, 
  Reaction,
  BaseResource,
  ResourceFromPrefix,
  ResourceTypeMap 
} from '@/lib/types';

// Global action client cache
const actionClientCache = new Map<string, ActionClient>();

// Get or create action client for workspace
function getActionClient(workspaceUrl: string): ActionClient {
  if (!actionClientCache.has(workspaceUrl)) {
    actionClientCache.set(workspaceUrl, createActionClient(workspaceUrl));
  }
  return actionClientCache.get(workspaceUrl)!;
}

// Base hook for action client
export function useActionClient(): ActionClient | null {
  const { workspace } = useCurrentWorkspace();
  
  return useMemo(() => {
    if (!workspace?.url) return null;
    return getActionClient(workspace.url);
  }, [workspace?.url]);
}

// Generic resource hooks factory
export function createResourceHooks<T = any>(actionPrefix: string) {
  return {
    useList: () => {
      return useActionQuery<T[]>(`${actionPrefix}.list`);
    },
    
    useGet: (id?: string) => useActionQuery<T>(`${actionPrefix}.get`, { 
      enabled: !!id,
      queryKey: [`${actionPrefix}.get`, id],
      resourceId: id
    }),
    
    useCreate: () => {
      const mutation = useActionMutation({ optimisticUpdate: true });
      return {
        ...mutation,
        create: async (data: any) => {
          return mutation.mutateAsync({
            action: `${actionPrefix}.create`,
            data
          });
        }
      };
    },
    
    useUpdate: () => {
      const mutation = useActionMutation({ optimisticUpdate: true });
      return {
        ...mutation,
        update: async (id: string, data: any) => {
          return mutation.mutateAsync({
            action: `${actionPrefix}.update`,
            resourceId: id,
            data
          });
        }
      };
    },
    
    useDelete: () => {
      const mutation = useActionMutation({ optimisticUpdate: true });
      return {
        ...mutation,
        delete: async (id: string) => mutation.mutateAsync({
          action: `${actionPrefix}.delete`,
          resourceId: id
        })
      };
    }
  };
}

// Auto-generated resource hooks for all standard resources
// These are now generated by the DatabaseFactory!
export const resourceHooks = {
  team: createResourceHooks<Team>('team'),
  project: createResourceHooks<Project>('project'),
  label: createResourceHooks<Label>('label'),
  labelGroup: createResourceHooks<BaseResource>('labelGroup'),
  member: createResourceHooks<Member>('member'),
  issueType: createResourceHooks<IssueType>('issueType'),
  statusFlow: createResourceHooks<StatusFlow>('statusFlow'),
  fieldSet: createResourceHooks<FieldSet>('fieldSet'),
  state: createResourceHooks<State>('state'),
  issue: createResourceHooks<Issue>('issue'),
  comment: createResourceHooks<Comment>('comment'),
  reaction: createResourceHooks<Reaction>('reaction'),
};

// Utility function to easily create new resource hooks for future resources
export function createNewResourceHooks<T = any>(actionPrefix: string) {
  return createResourceHooks<T>(actionPrefix);
}

// Generic mutation hook for actions
export function useActionMutation<T = any>(
  options?: {
    onSuccess?: (data: T, variables: ActionRequest) => void;
    onError?: (error: Error, variables: ActionRequest) => void;
    optimisticUpdate?: boolean;
  }
) {
  const client = useActionClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (request: ActionRequest): Promise<T> => {
      if (!client) throw new Error('No action client available');
      
      const operation = request.action.split('.')[1];
      const isTemporary = request.resourceId && request.resourceId.startsWith('temp-');
      
      // Handle temporary items purely optimistically
      if (isTemporary) {
        // For temporary items, don't send to server - just return optimistic data
        return { id: request.resourceId, ...request.data } as T;
      }
      
      const response = await client.executeAction<T>(request);
      
      if (!response.success) {
        console.error('‚ùå Action failed:', response.error);
        throw new Error(response.error || 'Action failed');
      }
      
      return response.data!;
    },
    onMutate: async (variables) => {
      if (options?.optimisticUpdate === false) return;
      
      const resourceType = variables.action.split('.')[0];
      const operation = variables.action.split('.')[1];
      
      // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({ 
        predicate: (query) => {
          const queryKey = query.queryKey;
          return Array.isArray(queryKey) && 
                 typeof queryKey[0] === 'string' && 
                 (queryKey[0].startsWith(resourceType) || 
                  (resourceType === 'state' && queryKey[0].startsWith('statusFlow')));
        }
      });
      
      // Snapshot the previous value
      const previousData = queryClient.getQueryData([`${resourceType}.list`]);
      
      // For state operations, get the statusFlow ID from the data
      let statusFlowId = null;
      if (resourceType === 'state') {
        if (variables.data?.statusFlowId) {
          statusFlowId = variables.data.statusFlowId;
        } else if (variables.resourceId) {
          // For updates/deletes, try to find the statusFlowId from existing data
          const existingStates = queryClient.getQueryData([`state.list`]) as any[];
          const existingState = existingStates?.find((s: any) => s.id === variables.resourceId);
          statusFlowId = existingState?.statusFlowId;
        }
      }
      
      const previousStatusFlowData = statusFlowId ? 
        queryClient.getQueryData([`statusFlow.get`, statusFlowId]) : null;
      
      // Optimistically update to the new value
      if (operation === 'create' && variables.data) {
        queryClient.setQueryData([`${resourceType}.list`], (old: any) => {
          if (!Array.isArray(old)) return old;
          const optimisticItem = { id: `temp-${Date.now()}`, ...variables.data };
          return [...old, optimisticItem];
        });
        
        // For state creation, also update the statusFlow
        if (resourceType === 'state' && statusFlowId) {
          queryClient.setQueryData([`statusFlow.get`, statusFlowId], (old: any) => {
            if (!old || old.id !== statusFlowId) return old;
            const optimisticState = { id: `temp-${Date.now()}`, ...variables.data };
            return {
              ...old,
              states: [...(old.states || []), optimisticState]
            };
          });
        }
      } else if (operation === 'update' && variables.resourceId && variables.data) {
        queryClient.setQueryData([`${resourceType}.list`], (old: any) => {
          if (!Array.isArray(old)) return old;
          return old.map((item: any) => 
            item.id === variables.resourceId ? { ...item, ...variables.data } : item
          );
        });
        
        // For state updates, also update the statusFlow
        if (resourceType === 'state' && statusFlowId) {
          queryClient.setQueryData([`statusFlow.get`, statusFlowId], (old: any) => {
            if (!old || old.id !== statusFlowId) return old;
            return {
              ...old,
              states: (old.states || []).map((state: any) => 
                state.id === variables.resourceId ? { ...state, ...variables.data } : state
              )
            };
          });
        }
      } else if (operation === 'delete' && variables.resourceId) {
        queryClient.setQueryData([`${resourceType}.list`], (old: any) => {
          if (!Array.isArray(old)) return old;
          return old.filter((item: any) => item.id !== variables.resourceId);
        });
        
        // For state deletion, also update the statusFlow
        if (resourceType === 'state' && statusFlowId) {
          queryClient.setQueryData([`statusFlow.get`, statusFlowId], (old: any) => {
            if (!old || old.id !== statusFlowId) return old;
            return {
              ...old,
              states: (old.states || []).filter((state: any) => state.id !== variables.resourceId)
            };
          });
        }
      }
      
      // Return a context object with the snapshotted value
      return { previousData, previousStatusFlowData };
    },
    onSuccess: (data, variables) => {
      const resourceType = variables.action.split('.')[0];
      const operation = variables.action.split('.')[1];
      
      // For create operations, replace the optimistic item with real server data
      if (operation === 'create' && data) {
        const serverData = data as any; // Cast to any since we're dealing with different resource types
        
        queryClient.setQueryData([`${resourceType}.list`], (old: any) => {
          if (!Array.isArray(old)) return old;
          
          // Find and replace the temporary item with real data
          return old.map((item: any) => {
            if (item.id && item.id.toString().startsWith('temp-')) {
              // Check if this looks like the item we just created
              if (item.name === serverData.name || item.statusFlowId === serverData.statusFlowId) {
                return serverData; // Replace temp item with real data
              }
            }
            return item;
          });
        });
        
        // Also update statusFlow cache for state creation
        if (resourceType === 'state' && serverData.statusFlowId) {
          queryClient.setQueryData([`statusFlow.get`, serverData.statusFlowId], (old: any) => {
            if (!old || old.id !== serverData.statusFlowId) return old;
            
            return {
              ...old,
              states: (old.states || []).map((state: any) => {
                if (state.id && state.id.toString().startsWith('temp-')) {
                  // Check if this looks like the state we just created
                  if (state.name === serverData.name) {
                    return serverData; // Replace temp state with real data
                  }
                }
                return state;
              })
            };
          });
        }
      }
      
      // Invalidate relevant queries to ensure fresh data
      queryClient.invalidateQueries({ 
        predicate: (query) => {
          const queryKey = query.queryKey;
          return Array.isArray(queryKey) && 
                 typeof queryKey[0] === 'string' && 
                 (queryKey[0].startsWith(resourceType) || 
                  (resourceType === 'state' && queryKey[0].startsWith('statusFlow')));
        }
      });
      
      options?.onSuccess?.(data, variables);
    },
    onError: (error, variables, context) => {
      // If the mutation fails, use the context returned from onMutate to roll back
      const resourceType = variables.action.split('.')[0];
      
      if (context?.previousData) {
        queryClient.setQueryData([`${resourceType}.list`], context.previousData);
      }
      
      if (context?.previousStatusFlowData && resourceType === 'state') {
        // Get the statusFlowId from the mutation variables
        let statusFlowId = null;
        if (variables.data?.statusFlowId) {
          statusFlowId = variables.data.statusFlowId;
        } else if (variables.resourceId) {
          // For updates/deletes, try to find the statusFlowId from existing data
          const existingStates = queryClient.getQueryData([`state.list`]) as any[];
          const existingState = existingStates?.find((s: any) => s.id === variables.resourceId);
          statusFlowId = existingState?.statusFlowId;
        }
        
        if (statusFlowId) {
          queryClient.setQueryData([`statusFlow.get`, statusFlowId], context.previousStatusFlowData);
        }
      }
      
      options?.onError?.(error, variables);
    }
  });
}

// Query hook with offline support and cache-first strategy
export function useActionQuery<T = any>(
  action: string,
  options?: {
    enabled?: boolean;
    staleTime?: number;
    gcTime?: number;
    retry?: boolean | number;
    queryKey?: any[];
    resourceId?: string;
  }
) {
  const client = useActionClient();
  
  return useQuery({
    queryKey: options?.queryKey || [action],
    queryFn: async (): Promise<T> => {
      if (!client) throw new Error('No action client available');
      
      // Try to get data from IndexedDB cache first
      const resourceType = action.split('.')[0];
      const operation = action.split('.')[1];
      
      if (operation === 'list' && resourceType) {
        // For list operations, try cache first
        const cachedData = await client.getCachedData<T>(resourceType);
        if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
          console.log(`üìã Serving ${resourceType} from cache (${cachedData.length} items)`);
          return cachedData as T;
        }
      }
      
      if (operation === 'get' && options?.resourceId) {
        // For get operations, try cache first
        const cachedData = await client.getCachedData<T>(resourceType, { id: options.resourceId });
        if (cachedData && Array.isArray(cachedData) && cachedData.length > 0) {
          console.log(`üìã Serving ${resourceType}/${options.resourceId} from cache`);
          return cachedData[0] as T;
        }
      }
      
      console.log(`üåê Fetching ${action} from server (not in cache)`);
      
      // Fallback to server if not in cache
      const actionRequest: any = { action };
      if (options?.resourceId) {
        actionRequest.resourceId = options.resourceId;
      }
      
      const response = await client.executeAction<T>(actionRequest);
      if (!response.success) {
        throw new Error(response.error || 'Query failed');
      }
      return response.data!;
    },
    enabled: !!client && (options?.enabled !== false),
    staleTime: options?.staleTime ?? 30 * 60 * 1000, // 30 minutes - longer for cache-first
    gcTime: options?.gcTime ?? 60 * 60 * 1000, // 1 hour - longer for cache-first
    retry: options?.retry ?? 1, // Less retries since we have cache fallback
    // Cache-first strategy: Don't refetch on mount, serve cached data immediately
    refetchOnMount: false,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });
}

// Offline status hook
export function useOfflineStatus() {
  const client = useActionClient();
  const [isOffline, setIsOffline] = useReactState(false);
  const [pendingCount, setPendingCount] = useReactState(0);
  
  useEffect(() => {
    if (!client) return;
    
    const checkStatus = () => {
      setIsOffline(client.isOffline());
      setPendingCount(client.getPendingActionsCount());
    };
    
    // Check immediately
    checkStatus();
    
    // Check periodically
    const interval = setInterval(checkStatus, 1000);
    
    return () => clearInterval(interval);
  }, [client]);
  
  return {
    isOffline,
    pendingCount,
    clearCache: () => client?.clearCache()
  };
} 